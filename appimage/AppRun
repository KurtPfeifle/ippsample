#!/bin/bash

# (c) 2017 Kurt Pfeifle
# License: MIT
#
# The purpose of this custom AppRun script is to enablesymlinking the AppImage and invoking the corresponding
# binary depending on which symlink name was used to invoke the AppImage.
#
# It also provides some additional help parameters in order to allow faster familiarization with functionality
# embedded in this AppImage.
#

HERE="$(dirname "$(readlink -f "${0}")")"

# https://github.com/istopwg/ippsample/blob/2c6a86046a5ef696792b6c22fd1bbeaef43647a8/config.h.in#L39-L51
export CUPS_DATADIR="$HERE/usr/share/cups"

#env

if [ "x$1" == "xhelp" -o "x$1" == "x--help" ] ; then
    echo ""
    echo " --------------------------------------------------------------------------------------------"
    echo "   Sample Implementation of an Internet Printing Protocol (IPP) Server with assorted Tools."
    echo "       Published by ISTO Printer Working Group (PWG), provided here as an AppImage."
    echo " --------------------------------------------------------------------------------------------"
    echo ""
    echo " (This package uses the AppImage software packaging technology"
    echo "  for Linux ['One App == One File'] for easy availability of"
    echo "  this IPP testing toolkit across all major Linux distributions.)"
    echo ""
    echo ""
    echo " Usage:"
    echo " ------"
    echo ""
    echo "   $ARGV0 help"
    echo "                 # This message"
    echo ""
    echo "   $ARGV0 ippserver|ippfind|ipptool|ippproxy"
    echo "                 # Run the named sub-command"
    echo ""
    echo "   $ARGV0 listtestdoc"
    echo "                 # List available, builtin test documents"
    echo ""
    echo "   $ARGV0 extracttestdoc"
    echo "                 # Extract available, builtin test documents"
    echo ""
    echo "   $ARGV0 listtest"
    echo "                 # List available, embedded IPP test files"
    echo ""
    echo "   $ARGV0 cat <testfile>"
    echo "                 # Print contents of named IPP test file"
    echo "                 # (By re-directing the output you can extract the file)"
    echo ""
    echo "   $ARGV0 listman"
    echo "                 # List available, embedded manual pages"
    echo ""
    echo "   $ARGV0 man ippserver|ippfind|ipptool|ipptoolfile|ippproxy"
    echo "                 # Display embedded manual page(s)"
    echo ""
    echo "   $ARGV0 listhtml"
    echo "                 # List as HTML embedded manual page(s)"
    echo ""
    echo "   $ARGV0 html ippserver|ippfind|ipptool|ipptoolfile|ippproxy"
    echo "                 # Use browser to display embedded manual page(s)"
    echo ""
    echo "   $ARGV0 listfile"
    echo "                 # List all files embedded in AppImage"
    echo ""
    echo "   $ARGV0 listexe"
    echo "                 # List all executables embedded in AppImage"
    echo ""
    echo "   $ARGV0 listreadme"
    echo "                 # List all READMEs embedded in AppImage"
    echo ""
    echo "   $ARGV0 readme <path/to/readme>"
    echo "                 # Show content of README embedded in AppImage (for path see \"$ARGV0 listreadme\")"
    echo ""
    echo "   $ARGV0 listdir"
    echo "                 # List all directories embedded in AppImage"
    echo ""
    echo "   $ARGV0 dir <path/to/dir>"
    echo "                 # Show content of directory embedded in AppImage (for path see \"$ARGV0 listdir\")"
    echo ""
    echo "   $ARGV0 --appimage-help"
    echo "                 # Show available AppImage options"
    echo ""
    echo " ---------------------------------------------------------------------------------------------"
    echo " NOTE: The execution of this AppImage is controlled by a custom AppRun script. The state of"
    echo " this script is experimental and preliminary. Hence it may not work as expected, or miss some"
    echo " functionality. You can hack on this script by unpacking this AppImage into a local sub"
    echo " directory [currently named 'squashfs-root'] with this command:"
    echo ""
    echo "       $ARGV0 --appimage-extract"
    echo ""
    echo " After you're done with your hacks, repackage the AppImage again with this command:"
    echo ""
    echo "       appimagetool [/path/to/]squashfs-root [/path/to/]ippsample.AppImage"
    echo ""
    echo " Latest versions of tools provided by AppImageKit are always available from"
    echo "   * https://github.com/AppImage/AppImageKit/releases/     and"
    echo "   * https://github.com/AppImage/AppImageUpdate/releases/"
    echo " ---------------------------------------------------------------------------------------------"
    echo ""
    exit $?
fi


if [ x"$1" == "xlistman" -o x"$1" == "x--listman" ] ; then
    cd "$HERE"
    echo ""
    find usr/share/man* -type f | sed 's#^# man #'
    echo ""
    exit $?
fi


if [ x"$1" == "xman"  -o  x"$1" == "x--man" ] ; then
    export MANPATH="$HERE/usr/share/man:$MANPATH"
    shift
    exec man "$@"
fi


if [ x"$1" == "xdir" -o x"$1" == "x--dir" ] ; then
    cd "$HERE"
    shift
    echo ""
    if [ x"$1" == "x" ] ; then
        echo " You must give a path to the directory you want to open."
        echo "   For available directories run \"$ARGV0 listdir\"."
    else
        xdg-open $HERE/$1
        sleep 3
    fi
    echo ""
    exit $?
fi


if [ x"$1" == "xlistdir" -o x"$1" == "x--listdir" ] ; then
    cd "$HERE"
    echo ""
    find . -type d | sed 's#^./#  dir #'
    echo ""
    exit $?
fi


if [ x"$1" == "xlistexe" -o x"$1" == "x--listexe" ] ; then
    cd "$HERE"
    echo ""
    find . -type f -o -type l -o -type s -o -type p | grep '/bin/' | sed 's#./usr/bin/#  #' | sort -V
    echo ""
    exit $?
fi


if [ x"$1" == "xlistfile" -o x"$1" == "x--listfile" ] ; then
    cd "$HERE"
    echo ""
    find . -type f -o -type l -o -type s -o -type p | sed 's#^./#  file #'
    echo ""
    exit $?
fi


if [ x"$1" == "xlistreadme" -o x"$1" == "x--listreadme" ] ; then
    cd "$HERE"
    echo ""
    find . -type f -name "*README*" -o -name "*readme*" -o -name "*.txt" -o -name "*.md" | sed 's#^./#  readme #'
    echo ""
    exit $?
fi


if [ x"$1" == "xreadme" -o x"$1" == "x--readme" ] ; then
    cd "$HERE"
    shift
    echo ""
    if [ x"$1" == "x" ] ; then
        echo " You must give a path to the README you want to open."
        echo "   For available READMEs run \"$ARGV0 listreadme\"."
    else
        readmefile=$( find . -type f -name "*README*" -o -name "*readme*" -o -name "*.txt" -o -name "*.md" | grep "${1}" | sort -rV | head -n 1 )
        cat $readmefile
        sleep 0
    fi
    echo ""
   exit $?
fi


if [ x"$1" == "xlisthtml"  -o x"$1" == "x--listhtml" ] ; then
    cd "$HERE"
    echo ""
    find -type f -name "*.html" | sed 's#^./#  html #'
    echo ""
    exit $?
fi


if [ x"$1" == "xhtml" -o x"$1" == "x--html" ] ; then
    cd "$HERE"
    shift
    echo ""
    if [ x"$1" == "x" ] ; then
        echo " You must give a path to the HTML file you want to open."
        echo "   For available HTML documents run \"$ARGV0 listhtml\"."
    else
        htmlfile=$( find . -type f -name "*.html" | grep ${1/.html/}.html | sort -rV | head -n 1 )
        xdg-open $htmlfile
        sleep 5
    fi
    echo ""
    exit $?
fi


if [ x"$1" == "xextracttestdoc" -o x"$1" == "x--extracttestdoc" ] ; then
    cd "$HERE/usr/share/cups/ipptool"
    shift 1
    echo ""
    if [ x"$1" == "x" ] ; then
        echo " You must give a path to the test document you want to extract."
        echo "   For available test documents run \"$ARGV0 listtestdoc\"."
    else
        testdocname=$( basename ${1} )
        mkdir -p ${HOME}/ai-tmp
        cat $1 > ${HOME}/ai-tmp/${testdocname}
        echo " Requested IPP print test document was extracted as '${HOME}/ai-tmp/${testdocname}'."
        sleep 0
    fi
    echo ""
    exit $?
fi


if [ x"$1" == "xcat" -o x"$1" == "x--cat" ] ; then
    cd "$HERE"
    shift 1
    echo ""
    if [ x"$1" == "x" ] ; then
        echo " You must give a path to the testfile file you want to see."
        echo "   For available testfiles run \"$ARGV0 listtest\"."
    else
        testfile=$( find . -type f -name "*.test" | grep "${1/.test/}.test" | sort -rV | head -n 1 )
        cat $testfile
        sleep 0
    fi
    echo ""
    exit $?
fi


if [ x"$1" == "xlisttestdoc" -o x"$1" == "x--listtestdoc" ] ; then
    shift 1
    cd $HERE/usr/share/cups/ipptool
    echo
    echo "======= 2D ================="
    echo "JPG:"
    ls -1 *.jpg   | sed 's#^#  #'
    echo
    echo "PCL:"
    ls -1 *.pcl   | sed 's#^#  #'
    echo
    echo "PDF:"
    ls -1 *.pdf   | sed 's#^#  #'
    echo
    echo "PostScript:"
    ls -1 *.ps    | sed 's#^#  #'
    echo
    echo "PWG-Raster:"
    ls -1 *.pwg.gz| sed 's#^#  #'
    echo
    echo
    echo "======= 3D ================="
    echo "3MF:"
    ls -1 *.3mf   | sed 's#^#  #'
    echo
    echo "SCAD:"
    ls -1 *.scad  | sed 's#^#  #'
    echo
    echo "SLA:"
    ls -1 *.sla   | sed 's#^#  #'
    echo
    echo "STL:"
    ls -1 *.stl   | sed 's#^#  #'
    echo
    echo "( ^^^^^^^^ 3D testing not yet supported)"
    echo "----------------------------------------"
    echo
    exit $?
fi


if [ x"$1" == "xlisttest" -o x"$1" == "x--listtest" ] ; then
    shift 1
    cd $HERE/usr/share/cups/ipptool
    exec ls *.test
fi


#set -x
if [ ! -z $APPIMAGE ] ; then
    BINARY_NAME=$(basename "$ARGV0")    # For this AppImage, BINARY_NAME will always be 'ippsample', which does not exist.
                                        # Only names currently supported are ippserver, ipptool, ippfind, ippproxy.
    #echo BINARY_NAME=$BINARY_NAME
    #echo APPIMAGE=$APPIMAGE
    #echo ARGV0=$ARGV0
    #echo dollar0=$0
    #echo dollar1=$1
    #echo dollar_at="$@"
    if [ x"$1" == "x" ] ; then
            exec "$HERE/usr/bin/ippserver"
    fi
    if [ -e "$HERE/usr/bin/$BINARY_NAME" ] ; then
        exec "$HERE/usr/bin/$BINARY_NAME" "$@"
    else
        if [ -e "$HERE/usr/bin/$1" ] ; then
            BINARY_NAME=$1
            shift
            exec "$HERE/usr/bin/$BINARY_NAME" "$@"
        elif [ x"$1" == xipptransform -o x"$1" == "xipptransform3d" ] ;then
            echo ""
            echo " ipptransform/ipptransform3 are not supported at this time."
            echo ""
            exit $?
        else
            exec "$HERE/usr/bin/ippserver" "$@"
        fi
    fi
else
      shift
      exec "$HERE/usr/bin/ippserver" "$@"
fi
